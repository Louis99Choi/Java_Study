package Equivalence;

import java.util.StringTokenizer;

import org.graalvm.compiler.core.common.cfg.Loop;

import LinkedList.*;
import UserUtil.UserInput;

public class Equivalence<E> {
	public SingleLinkedList<Integer>[] seq; // 각 LinkedList 객체(헤더노드)를 원소로 하는 배열

	int[] bit; // 변수출력 여부를 표시하는 비트배열
	int i, j; // 동치쌍 (i, j)
	int pairNum = 0; // m : 동치쌍의 수
	int elements; // n : 변수의 수
	int index = 0; // bit[] 배열의 index 변수;


	
	public static void main(String[] args) {
		Equivalence<Integer> equivalence = new Equivalence<Integer>();
		
		equivalence.input();
		equivalence.printClass();
		
	}
	
	
	/*
	 * 1단계 : 모든 입력을 처리. 사용자에게 1부터 n까지의 정수들의 동치관계를 동치쌍(ex_ 1=12)을 입력 받고 동치쌍을 열결리스트로
	 * 정리하는 매서드
	 */
	public void input() {
		System.out.print("1부터 정수 n까지의 동치관계를 동치쌍 형태로 입력 받아 동치 부류를 나눠 출력해주는 프로그램입니다.\n" + "최대 정수 n을 입력하시오 : ");
		elements = UserInput.getInteger(); // 사용자에게 n을 입력받음.(n은 element 수와 같음)

		this.bit = new int[elements];
		this.seq = new SingleLinkedList[elements];

		// 배열 bit[]와 seq[]의 원소를 각각 0과 null로 초기화.
		for (int i = 0; i < elements; i++) {
			bit[i] = 0;
			seq[i] = new SingleLinkedList<Integer>();
		}
		
		System.out.println();

		// 사용자로부터 동치쌍을 입력받음.{-1(등 음수)을 입력하면 동치쌍 입력을 종료}
		while (true) {
			System.out.printf("%d 번째 동치쌍 입력.(EX_ 1=9 / 음수를 입력하면 동치쌍 입력 종료) : ", pairNum + 1);

			StringTokenizer token = new StringTokenizer(UserInput.replaceEqual(UserInput.getNextLine()), " ");

			i = Integer.parseInt(token.nextToken()) - 1;

			if (i < 0) {
				break;
			} // 사용자의 입력이 -1 등 음수이면 동치쌍 입력 종료.

			j = Integer.parseInt(token.nextToken()) - 1;


			/*
			 * 
			 * 위의 실행들은 SingleLinkedList 클래스 객체 seq[i]의 인스턴스 메서드 push를 사용해 아래 과정으로 대체
			 * 가능하다.
			 */
			seq[i].push(j);
			seq[j].push(i);

			pairNum++;
		}

	}

	/*
	 * 2단계 : 모든 변수를 동치 관계에 대한 부류로 구분해 출력.
	 */
	public void printClass() {

		System.out.println("==================================================");
		char className = 'A';
		int classCount = 0;
		
		while (index < elements) {
			
			if (bit[index] == 0) {
				System.out.printf("\n{ %c Class : %d", className + (classCount++), index+1);
				bit[index] = 1;

				SingleNode<Integer> ptrNode = new SingleNode<Integer>(seq[index].getTop());
				SingleLinkedList<Integer> stack = new SingleLinkedList<Integer>(); //스택 초기화;

				Loop1 : while(true) {
					while(ptrNode != null) {
						j = ptrNode.getData(); // j <- DATA(ptr)

						if (bit[j] == 0) {
							System.out.printf(", %d", j+1); // print(j);
							bit[j] = 1;					  // BIT(j) <- 1;

							
							/*
							 * t <- LINK(ptr);	LINK(ptr) <- top;	top <- ptr;	ptr <- t;
							 * 이 네가지 실행은 SEQ(index)첫번째 노드를 pop해서 stack에 push 하는 것과 같다.
							 */
							stack.push(seq[index].popNode()); //SEQ(index)첫번째 노드를 pop해서 stack에 push.
							ptrNode = seq[index].getTop(); //ptr 에 다음 노드 저장.
						}
						
						else {
							if(seq[index].getTop() != null)
								seq[index].setTop(seq[index].getTop().getLink()); // ptr <- LINK(ptr);
						}

					}
					
					if (stack.getTop() == null) break Loop1; //if top = 0 then exit
					
					if(ptrNode == null) { ptrNode = new SingleNode<>(); }
					
					ptrNode = new SingleNode<Integer>(seq[ (int)stack.popNode().getData() ].getTop() ); // ptr <- SEQ(DATA(top)), top <- LINK(top).
					
				}
								
			}

			index++;
		}

	}

}
